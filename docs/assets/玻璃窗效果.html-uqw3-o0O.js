import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c as t,a as l}from"./app-lPatJsT1.js";const r="/assets/image-fsrVGpmJ.png",e="/assets/image-1-dOCT6MhC.png",s="/assets/image-2-FEj8zzGw.png",o="/assets/image-4-T0CUtTCX.png",n="/assets/image-3-8iIUgOIC.png",d={},c=l('<h2 id="透明度测试" tabindex="-1"><a class="header-anchor" href="#透明度测试" aria-hidden="true">#</a> 透明度测试</h2><figure><img src="'+r+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><ul><li>如果不对透明纹素进行处理的话，默认就会取纹素自带的颜色呈现，如下图： <img src="'+e+'" alt="alt text" loading="lazy"></li></ul><h3 id="解决" tabindex="-1"><a class="header-anchor" href="#解决" aria-hidden="true">#</a> 解决</h3><h4 id="discard" tabindex="-1"><a class="header-anchor" href="#discard" aria-hidden="true">#</a> discard</h4><ul><li>定义一个阈值 小于阈值就调用discard; 缺点: 但是我们可能需要多个透明物体之间相互作用的效果 这种方式不能满足</li></ul><h4 id="混合" tabindex="-1"><a class="header-anchor" href="#混合" aria-hidden="true">#</a> 混合</h4><ul><li>启用混合时需要关闭深度测试</li></ul><p><strong>混合方程</strong><strong>color(RGBA) = ((sourceColor * sfactor) + (destinationColor * dfactor)). RBGA</strong></p><ul><li>sourceColor：源颜色向量。这是源自纹理的颜色向量。</li><li>destinationColor：目标颜色向量。这是当前储存在颜色缓冲中的颜色向量。</li><li>sfactor：源因子值。指定了 alpha 值对源颜色的影响。</li><li>dfactor：目标因子值。指定了 alpha 值对目标颜色的影响。</li></ul><p><strong>因子设置表</strong><img src="'+s+'" alt="alt text" loading="lazy"></p><p><strong>混合设置</strong><img src="'+o+'" alt="alt text" loading="lazy"><em><strong>方程表示为（这里的源使用 50% 透明度区域(0.9, 0, 0.6, 0.5)，颜色缓冲假设是纯绿色(0, 1, 0, 1)）:</strong></em></p><ul><li>color(RGB) = (0.9, 0, 0.6) * 0.5 + (0, 1, 0) * (1 - 0.5)</li><li></li><li></li><li>color(A) = 0.5 * 1 + 1 * 0</li></ul><h5 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h5><p>先渲染了一个半透明物体（半透明物体距离相机更近），再渲染一个不透明物体（不透明物体距离相机更远）: <img src="'+n+'" alt="alt text" loading="lazy"></p><h5 id="解决如下" tabindex="-1"><a class="header-anchor" href="#解决如下" aria-hidden="true">#</a> 解决如下：</h5><ul><li>先绘制所有不透明的物体；</li><li>对所有透明的物体排序，采用的是观察者视角，即距离相机的远近，“大多数”情况下，不开启深度测试；</li><li>按照从远到近的顺序绘制透明物体。</li></ul>',17),h=[c];function g(_,p){return i(),t("div",null,h)}const f=a(d,[["render",g],["__file","玻璃窗效果.html.vue"]]);export{f as default};
