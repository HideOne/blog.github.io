import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as l,o as i}from"./app-BgJE7HsM.js";const r="/assets/image-B-ytUamY.png",o="/assets/image-1-B04JPoyE.png",n="/assets/image-2-USPzPMbC.png",s="/assets/image-4-BPQJS1MJ.png",c="/assets/image-3-DyIhSA4g.png",d={};function p(h,t){return i(),a("div",null,t[0]||(t[0]=[l('<h2 id="透明度测试" tabindex="-1"><a class="header-anchor" href="#透明度测试"><span>透明度测试</span></a></h2><figure><img src="'+r+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><ul><li>如果不对透明纹素进行处理的话，默认就会取纹素自带的颜色呈现，如下图： <img src="'+o+'" alt="alt text" loading="lazy"></li></ul><h3 id="解决" tabindex="-1"><a class="header-anchor" href="#解决"><span>解决</span></a></h3><h4 id="discard" tabindex="-1"><a class="header-anchor" href="#discard"><span>discard</span></a></h4><ul><li>定义一个阈值 小于阈值就调用discard; 缺点: 但是我们可能需要多个透明物体之间相互作用的效果 这种方式不能满足</li></ul><h4 id="混合" tabindex="-1"><a class="header-anchor" href="#混合"><span>混合</span></a></h4><ul><li>启用混合时需要关闭深度测试</li></ul><p><strong>混合方程</strong><strong>color(RGBA) = ((sourceColor * sfactor) + (destinationColor * dfactor)). RBGA</strong></p><ul><li>sourceColor：源颜色向量。这是源自纹理的颜色向量。</li><li>destinationColor：目标颜色向量。这是当前储存在颜色缓冲中的颜色向量。</li><li>sfactor：源因子值。指定了 alpha 值对源颜色的影响。</li><li>dfactor：目标因子值。指定了 alpha 值对目标颜色的影响。</li></ul><p><strong>因子设置表</strong><img src="'+n+'" alt="alt text" loading="lazy"></p><p><strong>混合设置</strong><img src="'+s+'" alt="alt text" loading="lazy"><em><strong>方程表示为（这里的源使用 50% 透明度区域(0.9, 0, 0.6, 0.5)，颜色缓冲假设是纯绿色(0, 1, 0, 1)）:</strong></em></p><ul><li>color(RGB) = (0.9, 0, 0.6) * 0.5 + (0, 1, 0) * (1 - 0.5)</li><li></li><li></li><li>color(A) = 0.5 * 1 + 1 * 0</li></ul><h5 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h5><p>先渲染了一个半透明物体（半透明物体距离相机更近），再渲染一个不透明物体（不透明物体距离相机更远）: <img src="'+c+'" alt="alt text" loading="lazy"></p><h5 id="解决如下" tabindex="-1"><a class="header-anchor" href="#解决如下"><span>解决如下：</span></a></h5><ul><li>先绘制所有不透明的物体；</li><li>对所有透明的物体排序，采用的是观察者视角，即距离相机的远近，“大多数”情况下，不开启深度测试；</li><li>按照从远到近的顺序绘制透明物体。</li></ul>',17)]))}const u=e(d,[["render",p],["__file","玻璃窗效果.html.vue"]]),f=JSON.parse('{"path":"/posts/%E6%B8%B8%E6%88%8F/Shader/shader%E5%BA%94%E7%94%A8/%E7%8E%BB%E7%92%83%E7%AA%97%E6%95%88%E6%9E%9C.html","title":"玻璃窗效果","lang":"zh-CN","frontmatter":{"title":"玻璃窗效果","category":["shader应用"],"date":"2024-05-17T08:46:15.000Z","description":"透明度测试 alt textalt text 如果不对透明纹素进行处理的话，默认就会取纹素自带的颜色呈现，如下图： alt text 解决 discard 定义一个阈值 小于阈值就调用discard; 缺点: 但是我们可能需要多个透明物体之间相互作用的效果 这种方式不能满足 混合 启用混合时需要关闭深度测试 混合方程 color(RGBA) = ((s...","head":[["meta",{"property":"og:url","content":"https://blog.vipfreevpn.top/posts/%E6%B8%B8%E6%88%8F/Shader/shader%E5%BA%94%E7%94%A8/%E7%8E%BB%E7%92%83%E7%AA%97%E6%95%88%E6%9E%9C.html"}],["meta",{"property":"og:site_name","content":"博客"}],["meta",{"property":"og:title","content":"玻璃窗效果"}],["meta",{"property":"og:description","content":"透明度测试 alt textalt text 如果不对透明纹素进行处理的话，默认就会取纹素自带的颜色呈现，如下图： alt text 解决 discard 定义一个阈值 小于阈值就调用discard; 缺点: 但是我们可能需要多个透明物体之间相互作用的效果 这种方式不能满足 混合 启用混合时需要关闭深度测试 混合方程 color(RGBA) = ((s..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-18T14:03:14.000Z"}],["meta",{"property":"article:published_time","content":"2024-05-17T08:46:15.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-18T14:03:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"玻璃窗效果\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-17T08:46:15.000Z\\",\\"dateModified\\":\\"2024-05-18T14:03:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HideOne\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"透明度测试","slug":"透明度测试","link":"#透明度测试","children":[{"level":3,"title":"解决","slug":"解决","link":"#解决","children":[{"level":4,"title":"discard","slug":"discard","link":"#discard","children":[]},{"level":4,"title":"混合","slug":"混合","link":"#混合","children":[{"level":5,"title":"问题","slug":"问题","link":"#问题","children":[]},{"level":5,"title":"解决如下：","slug":"解决如下","link":"#解决如下","children":[]}]}]}]}],"git":{"createdTime":1716023636000,"updatedTime":1716040994000,"contributors":[{"name":"HideOne","email":"844085696@qq.com","commits":2}]},"readingTime":{"minutes":1.34,"words":402},"filePathRelative":"posts/游戏/Shader/shader应用/玻璃窗效果.md","localizedDate":"2024年5月17日","excerpt":"<h2>透明度测试</h2>\\n<figure><figcaption>alt text</figcaption></figure>\\n<ul>\\n<li>如果不对透明纹素进行处理的话，默认就会取纹素自带的颜色呈现，如下图：\\n</li>\\n</ul>\\n<h3>解决</h3>\\n<h4>discard</h4>\\n<ul>\\n<li>定义一个阈值 小于阈值就调用discard; 缺点: 但是我们可能需要多个透明物体之间相互作用的效果 这种方式不能满足</li>\\n</ul>\\n<h4>混合</h4>\\n<ul>\\n<li>启用混合时需要关闭深度测试</li>\\n</ul>\\n<p><strong>混合方程</strong>\\n<strong>color(RGBA) = ((sourceColor * sfactor) + (destinationColor * dfactor)). RBGA</strong></p>","autoDesc":true}');export{u as comp,f as data};
