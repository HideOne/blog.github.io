import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as t,o as l}from"./app-CwuUQOwE.js";const i="/assets/image-4-oMQELn.png",p="/assets/image-1-aQV-MOG_.png",e="/assets/image-2-B-Ajlxg0.png",m="/assets/image-3-CdC1Qx6N.png",r="/assets/image-4-DtzSlJV-.png",o="/assets/image-6-BFwybvdg.png",c={};function g(h,s){return l(),n("div",null,s[0]||(s[0]=[t('<h2 id="光栅化" tabindex="-1"><a class="header-anchor" href="#光栅化"><span>光栅化</span></a></h2><ul><li>把东西画在频幕上</li></ul><p>光栅化（Rasterization）是计算机图形学中将矢量图形（如点、线、三角形等几何图形）转换为光栅图形（即像素网格）的过程。这个过程通常用于实时渲染和显示三维图形到二维屏幕上。以下是光栅化的基本步骤和概念：</p><ol><li><p><strong>顶点处理（Vertex Processing）</strong>：首先，图形的顶点数据（如位置、颜色、纹理坐标等）通过顶点着色器进行处理，进行变换和投影。</p></li><li><p><strong>裁剪（Clipping）</strong>：将超出视口或视锥体外的部分裁剪掉，只保留需要绘制的部分。</p></li><li><p><strong>三角形设置（Triangle Setup）</strong>：计算三角形的边缘方程，准备进行光栅化。</p></li><li><p><strong>光栅化（Rasterization）</strong>：</p><ul><li><strong>采样</strong>：确定哪些像素（或片段）应该被绘制。通常使用边缘方程来判断一个像素是否在三角形内部。</li><li><strong>插值</strong>：对顶点属性（如颜色、纹理坐标）进行插值，以确定每个像素的最终值。</li></ul></li><li><p><strong>片段着色（Fragment Shading）</strong>：每个片段（像素）通过片段着色器进行处理，这里可以进行纹理映射、光照计算等。</p></li><li><p><strong>深度测试（Depth Testing）</strong>：决定哪些片段应该被绘制到屏幕上，通过比较深度缓冲区中的值。</p></li><li><p><strong>混合（Blending）</strong>：如果有透明或半透明的对象，可能需要进行混合操作来正确渲染透明度。</p></li></ol><p>光栅化是图形管线中的一个关键步骤，它决定了图形如何从三维空间转换到二维显示设备上。在实时图形应用中（如游戏、虚拟现实），光栅化需要非常高效，因为它直接影响渲染性能。现代GPU（图形处理单元）高度优化了这个过程，能够在极短的时间内处理大量的几何数据和像素。</p><h2 id="透视投影" tabindex="-1"><a class="header-anchor" href="#透视投影"><span>透视投影</span></a></h2><p>透视投影（Perspective Projection）是计算机图形学和摄影中常用的一种投影方式，用于将三维场景映射到二维平面上，模拟人类视觉系统的深度感和透视效果。以下是透视投影的几个关键点：</p><ol><li><p><strong>消失点（Vanishing Points）</strong>：在透视投影中，平行线在无限远处的交汇点被称为消失点。水平线的消失点通常位于视平线（horizon line）上，垂直线和深度方向的线也可能有自己的消失点。</p></li><li><p><strong>视锥体（View Frustum）</strong>：透视投影定义了一个视锥体，任何在这个视锥体内的物体都会被投影到视平面上，视锥体之外的物体则被裁剪掉。</p></li><li><p><strong>视点（Viewpoint or Camera Position）</strong>：这是观察者（或虚拟摄像机）所在的位置，所有的投影计算都是基于这个点进行的。</p></li><li><p><strong>投影平面（Projection Plane）</strong>：这是实际进行投影的平面，通常与视点垂直。物体被投影到这个平面上。</p></li><li><p><strong>投影矩阵（Projection Matrix）</strong>：</p><ul><li>在计算机图形学中，使用投影矩阵将三维坐标转换到二维屏幕空间。透视投影矩阵会将远处的物体变小，近处的物体变大，产生一种深度的错觉。</li><li>透视投影矩阵通常涉及到视野（Field of View, FOV）、纵横比（Aspect Ratio）、近平面（Near Plane）和远平面（Far Plane）等参数。</li></ul></li><li><p><strong>透视缩放（Perspective Scaling）</strong>：物体离视点越远，在投影平面上看起来就越小，这种缩放效应模拟了人眼的视觉特性。</p></li><li><p><strong>线性透视（Linear Perspective）</strong>：这是透视投影的一种形式，遵循几何透视规律，物体的大小与其距离视点成反比。</p></li></ol><p>透视投影的主要特点是它能够很好地模拟人类的视觉感知，使得渲染的场景看起来更加真实和有深度感。相比之下，正交投影（Orthographic Projection）则不考虑距离，只保持物体的相对大小不变，因此不具备深度感。</p><p>在计算机图形学中，透视投影通常通过变换矩阵实现，这些矩阵会将三维坐标转换为标准化设备坐标（Normalized Device Coordinates, NDC），然后再经过视口变换映射到屏幕坐标。透视投影的计算和优化是图形渲染中的一个重要部分，特别是在需要高质量实时渲染的场景中。</p><h2 id="mvp" tabindex="-1"><a class="header-anchor" href="#mvp"><span>MVP</span></a></h2><p>在计算机图形学中，MVP是一个常见的缩写，代表的是三个关键的变换矩阵：</p><ol><li><p><strong>Model Matrix（模型矩阵）</strong>：</p><ul><li>模型矩阵用于将模型从其自身的坐标系统（局部坐标系）转换到世界坐标系。它可以包括缩放、旋转、平移等变换，定义了模型在世界空间中的位置、大小和朝向。</li></ul></li><li><p><strong>View Matrix（视图矩阵）</strong>：</p><ul><li>视图矩阵，也被称为摄像机矩阵或视图变换矩阵，将世界坐标系转换到相对于摄像机的位置和方向的坐标系中。视图矩阵实质上是将摄像机移动到原点并使其朝向负Z轴方向的变换。</li></ul></li><li><p><strong>Projection Matrix（投影矩阵）</strong>：</p><ul><li>投影矩阵将视图空间中的点转换到裁剪空间（也称为标准化设备坐标，NDC），这个空间是一个立方体，范围通常是[-1, 1]在每个轴上。投影矩阵决定了如何将三维场景投影到二维平面上，常见的有透视投影和正交投影。</li></ul></li></ol><p>这些矩阵通常是按顺序应用的：</p><ul><li><strong>Model</strong> → <strong>View</strong> → <strong>Projection</strong></li></ul><p>这个顺序意味着：</p><ul><li>首先，模型矩阵将顶点从模型空间转换到世界空间。</li><li>然后，视图矩阵将世界空间的点转换到相对于摄像机的空间。</li><li>最后，投影矩阵将这些点转换到裁剪空间。</li></ul><p>在实际的渲染管线中，顶点着色器（Vertex Shader）通常会接收顶点数据并进行这些变换：</p><div class="language-glsl line-numbers-mode" data-highlighter="shiki" data-ext="glsl" data-title="glsl" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">gl_Position </span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> projectionMatrix </span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> viewMatrix </span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> modelMatrix </span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> vec4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(position, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中，<code>position</code> 是顶点在模型空间中的位置，<code>gl_Position</code> 是最终在裁剪空间中的位置。</p><p>MVP矩阵的组合是实时图形渲染中的基础步骤，它决定了如何将三维模型正确地投影到二维屏幕上，同时考虑了模型自身的变换、摄像机的位置和朝向以及投影方式。不同的渲染引擎或API（如OpenGL、DirectX、WebGL等）可能有不同的方式来设置和应用这些矩阵，但核心概念是相同的。</p><p>将[-1,1]转到 [0,width] [0,heigh] <img src="'+i+'" alt="alt text" loading="lazy"></p><h2 id="三角形" tabindex="-1"><a class="header-anchor" href="#三角形"><span>三角形</span></a></h2><p>三角形在计算机图形学中具有基础性和重要性的地位，以下是几点说明其根本性：</p><ol><li><p><strong>几何简单性</strong>：</p><ul><li>三角形是三维空间中最简单的多边形，只有三个顶点和三条边，这使得其几何计算相对简单，适合于高效的数学处理。</li></ul></li><li><p><strong>平面性</strong>：</p><ul><li>任何三角形都完全平面，不存在弯曲或扭曲，这意味着在光栅化或投影过程中，三角形内的点可以简单地通过线性插值来确定。</li></ul></li><li><p><strong>光栅化友好</strong>：</p><ul><li>三角形可以被很容易地光栅化。光栅化三角形只需要判断像素是否在三角形内部，这种判断可以通过边缘方程或重心坐标来进行。</li></ul></li><li><p><strong>投影和裁剪</strong>：</p><ul><li>在透视投影和视锥体裁剪过程中，三角形保持其完整性，不会像四边形或更复杂的多边形那样可能被分割成多个部分。</li></ul></li><li><p><strong>曲面逼近</strong>：</p><ul><li>复杂的曲面可以通过多个三角形来逼近（称为三角剖分），这允许我们使用简单图形来表示复杂的几何形状。</li></ul></li><li><p><strong>顶点属性插值</strong>：</p><ul><li>三角形内的顶点属性（如颜色、纹理坐标、法线等）可以使用重心坐标进行线性插值，这在着色过程中非常有用。</li></ul></li><li><p><strong>硬件加速</strong>：</p><ul><li>现代图形硬件（GPU）通常优化了对三角形的处理，包括光栅化、着色和深度测试等操作。</li></ul></li><li><p><strong>一致性</strong>：</p><ul><li>使用三角形作为基本渲染单位，确保了图形渲染的统一性和可预测性，无论是简单还是复杂的场景。</li></ul></li><li><p><strong>拓扑结构</strong>：</p><ul><li>三角形提供了稳定的拓扑结构，不会出现像四边形可能出现的退化情况（如变成线或点）。</li></ul></li><li><p><strong>数学模型</strong>：</p><ul><li>三角形在数学上有着完备的描述，包括重心坐标、面积计算、法线计算等，这些都为图形计算提供了坚实的基础。</li></ul></li><li><p><strong>物理模拟</strong>：</p><ul><li>在物理引擎中，三角形网格常用于碰撞检测和物理模拟，因为其简单性和计算效率。</li></ul></li></ol><p>由于这些特性，三角形成为图形渲染的基本单位，任何复杂的模型最终都会被分解成三角形集合进行渲染。这使得三角形在计算机图形学中成为一个根本性的概念，支持了从基本的几何变换到高级渲染技术的所有方面。</p><h2 id="采样" tabindex="-1"><a class="header-anchor" href="#采样"><span>采样</span></a></h2><h4 id="采样是什么" tabindex="-1"><a class="header-anchor" href="#采样是什么"><span>采样是什么？</span></a></h4><p>采样就像是用快照来捕捉某个事物的一系列瞬间画面。比如，当你看电影时，你看到的其实是一系列快速播放的静止图片，这些图片就是从连续的电影胶片中“采样”出来的。</p><p>定义： 采样就是从一个连续的、变化的事物中挑选出特定的点或时刻，来代表这个事物的整体状态或特性。</p><p><img src="'+p+'" alt="alt text" loading="lazy"><img src="'+e+'" alt="alt text" loading="lazy"></p><p>函数离散化的过程</p><p>在计算机图形学中，采样（Sampling）指的是从连续或离散信号中获取有限数量的数据点，以便进行图像生成或处理。“A Simple Approach” 通常意味着采用直接且容易实现的方法来完成采样，而不是复杂的数学模型或优化算法。</p><h2 id="采样伪像-sampling-artifacts-反走样" tabindex="-1"><a class="header-anchor" href="#采样伪像-sampling-artifacts-反走样"><span>采样伪像（Sampling Artifacts） 反走样</span></a></h2><ul><li>采样频率更不上物体更新速度</li></ul><h3 id="锯齿-aliasing" tabindex="-1"><a class="header-anchor" href="#锯齿-aliasing"><span>锯齿（Aliasing）</span></a></h3><p><strong>Aliasing (Jaggies)</strong> 是计算机图形学中的一种常见现象，通常出现在图像处理或渲染过程中，尤其是在低分辨率显示或图像采样不足时。它会导致图像中出现锯齿状或不规则的边缘，通常被称为“<strong>jaggies</strong>”。这种现象主要是由于采样不充分或对连续信号的离散表示造成的。 <img src="'+m+'" alt="alt text" loading="lazy"></p><h4 id="aliasing的成因" tabindex="-1"><a class="header-anchor" href="#aliasing的成因"><span><strong>Aliasing的成因</strong></span></a></h4><p>在计算机图形学中，<strong>采样</strong>（Sampling）是将连续图像或几何形状转化为数字形式的过程。当我们用有限的像素数来表示连续图形或曲线时，如果采样不足，特别是在边缘或高频细节的区域，可能无法准确地捕捉到图像的细节。这时，图像的边缘就可能出现锯齿状的伪影——即<strong>Aliasing</strong>。</p><hr><h4 id="aliasing的具体表现" tabindex="-1"><a class="header-anchor" href="#aliasing的具体表现"><span><strong>Aliasing的具体表现</strong></span></a></h4><ol><li><strong>锯齿边缘（Jaggies）</strong>：物体的直线或曲线边缘变得不平滑，形成一系列阶梯状的伪影。</li><li><strong>频率混叠</strong>：在图像中，高频细节（如斜线或曲线）会“折叠”成低频模式，造成失真。</li><li><strong>摩尔纹（Moire Patterns）</strong>：当低分辨率图像的细节过度采样时，可能会产生类似于干扰条纹的图案。</li></ol><hr><h4 id="aliasing的原因" tabindex="-1"><a class="header-anchor" href="#aliasing的原因"><span><strong>Aliasing的原因</strong></span></a></h4><ol><li><strong>采样率不足</strong>：如果采样的分辨率不足，无法捕捉到信号的所有细节，特别是在图像的高频区域，容易出现aliasing。</li><li><strong>离散化误差</strong>：在将连续的几何或颜色信息转化为离散数据时，由于有限的像素或采样点，会产生误差。</li><li><strong>信号频率过高</strong>：如果图像中的细节（比如边缘的变化）频率高于采样的分辨率，无法正确表示这些细节，导致aliasing。</li></ol><hr><h3 id="莫尔条纹-moire-patterns" tabindex="-1"><a class="header-anchor" href="#莫尔条纹-moire-patterns"><span>莫尔条纹（Moiré Patterns）</span></a></h3><p><img src="'+r+'" alt="alt text" loading="lazy"> **莫尔条纹（Moiré Patterns）**表现为当两个具有相似或重复的图案（如线条、网格或点阵）叠加并稍微错开时，出现一种新的、低频的干涉图案。这种条纹通常比原始图案的结构更大、更显眼。</p><h4 id="描述" tabindex="-1"><a class="header-anchor" href="#描述"><span>描述</span></a></h4><ul><li><strong>莫尔条纹</strong>是由于两个或多个周期性图案的干涉而产生的视觉效应。这些图案的周期性结构相互叠加时，会产生新的、意外的图案，这些图案通常是低频的波纹或条纹。</li></ul><h4 id="成因" tabindex="-1"><a class="header-anchor" href="#成因"><span>成因</span></a></h4><ul><li><strong>采样频率</strong>：当两个图案的频率接近时，采样频率不足以捕捉它们的细节，导致混叠效应。</li><li><strong>网格或线条</strong>：在成像中，常见于显示器、屏幕、相机传感器的像素阵列与被摄物体上的细密图案（如织物、网格、条纹等）之间的相互作用。</li></ul><h4 id="例子" tabindex="-1"><a class="header-anchor" href="#例子"><span>例子</span></a></h4><ul><li><strong>屏幕上的网格</strong>：当你通过相机拍摄电脑屏幕或电视屏幕时，如果屏幕上的图案与相机传感器的像素阵列频率接近，可能会在图像中看到莫尔条纹。</li><li><strong>织物上的图案</strong>：拍摄带有细密图案的织物，如格子布或条纹布，可能会在图像中产生莫尔条纹。</li><li><strong>印刷品</strong>：在印刷品上，细密的网点或线条在扫描或拍摄时也可能产生莫尔条纹。</li></ul><h4 id="影响" tabindex="-1"><a class="header-anchor" href="#影响"><span>影响</span></a></h4><ul><li><strong>视觉干扰</strong>：莫尔条纹会使图像看起来不自然，降低图像的质量和可读性。</li><li><strong>信息损失</strong>：在某些情况下，莫尔条纹可能掩盖了图像中的重要细节。</li></ul><h4 id="反走样解决方法" tabindex="-1"><a class="header-anchor" href="#反走样解决方法"><span>反走样解决方法**</span></a></h4><p>对原始函数（信号）做模糊（滤波）</p><p>为了减少或消除aliasing，通常采用以下几种技术：</p><h5 id="_1-超采样-supersampling" tabindex="-1"><a class="header-anchor" href="#_1-超采样-supersampling"><span><strong>1. 超采样（Supersampling）</strong></span></a></h5><ul><li><strong>方法</strong>：超采样是通过增加每个像素的采样数量来减轻aliasing。例如，每个像素取多个样本，然后计算这些样本的平均值，从而获得更平滑的结果。</li><li><strong>优点</strong>：能有效减少锯齿效果。</li><li><strong>缺点</strong>：计算量增加，需要更多的处理资源。</li></ul><h5 id="_2-多重采样抗锯齿-msaa-multi-sample-anti-aliasing" tabindex="-1"><a class="header-anchor" href="#_2-多重采样抗锯齿-msaa-multi-sample-anti-aliasing"><span><strong>2. 多重采样抗锯齿（MSAA, Multi-Sample Anti-Aliasing）</strong></span></a></h5><ul><li><strong>方法</strong>：MSAA是一种抗锯齿技术，通过在多个点上采样每个像素，然后根据这些样本的平均值来确定最终颜色。与超采样相比，MSAA通常减少了计算量，因为它只对像素的边缘部分进行额外的采样。</li><li><strong>优点</strong>：计算效率较高，适用于实时渲染。</li><li><strong>缺点</strong>：相比超采样，效果略逊。</li></ul><h5 id="_3-fxaa-fast-approximate-anti-aliasing" tabindex="-1"><a class="header-anchor" href="#_3-fxaa-fast-approximate-anti-aliasing"><span><strong>3. FXAA (Fast Approximate Anti-Aliasing)</strong></span></a></h5><ul><li><strong>方法</strong>：FXAA是一种基于图像后处理的抗锯齿方法，通过对图像进行平滑处理来减少锯齿。它的处理速度快，适用于实时渲染。</li><li><strong>优点</strong>：非常高效，适用于性能有限的设备。</li><li><strong>缺点</strong>：效果不如其他方法如MSAA或SSAA精细。</li></ul><h5 id="_4-temporal-anti-aliasing-taa" tabindex="-1"><a class="header-anchor" href="#_4-temporal-anti-aliasing-taa"><span><strong>4. Temporal Anti-Aliasing (TAA)</strong></span></a></h5><ul><li><strong>方法</strong>：TAA利用时间信息，通过对多个帧之间的像素值进行加权平均，从而减少aliasing。它适合于动态图像。</li><li><strong>优点</strong>：能在动态场景中提供平滑效果，减少噪点和锯齿。</li><li><strong>缺点</strong>：可能会出现运动模糊或拖影现象。</li></ul><h5 id="_5-采样率调整-adaptive-sampling" tabindex="-1"><a class="header-anchor" href="#_5-采样率调整-adaptive-sampling"><span><strong>5. 采样率调整（Adaptive Sampling）</strong></span></a></h5><ul><li><strong>方法</strong>：在某些区域增加采样密度，而在其他区域降低采样密度。通常在图像的细节较多的区域使用更密集的采样，以便更准确地表示。</li><li><strong>优点</strong>：能够提高渲染效率，同时减少 aliasing。</li><li><strong>缺点</strong>：需要额外的计算和算法调整。</li></ul><hr><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span><strong>总结</strong></span></a></h4><p><strong>Aliasing</strong>（锯齿效应）是由于采样不足或分辨率低导致图像中出现的伪影现象，特别是在图像的边缘和细节部分。为了减轻aliasing效果，常用的技术包括超采样、多重采样抗锯齿、FXAA、TAA等。虽然这些方法有不同的优缺点，但它们的共同目标是通过增加采样或使用后处理技术来使图像边缘变得更加平滑，消除锯齿状伪影。</p><h2 id="频域-frequency-domain" tabindex="-1"><a class="header-anchor" href="#频域-frequency-domain"><span>频域（Frequency Domain）</span></a></h2><p>在计算机图形学中，<strong>频域（Frequency Domain）</strong> 是一种从信号或图像的频率分量角度来分析和处理数据的方法。它是时域/空间域的互补表示，利用傅里叶变换将时域或空间域的信号转换为频域表示。以下是频域的概念、数学基础及其在计算机图形学中的应用。</p><hr><h3 id="_1-基本概念" tabindex="-1"><a class="header-anchor" href="#_1-基本概念"><span><strong>1. 基本概念</strong></span></a></h3><h4 id="时域与频域" tabindex="-1"><a class="header-anchor" href="#时域与频域"><span>时域与频域</span></a></h4><ul><li><strong>时域/空间域（Time/Spatial Domain）：</strong> 描述信号（如图像像素值）随时间或空间的变化。</li><li><strong>频域（Frequency Domain）：</strong> 描述信号中频率分量的分布，包括幅度和相位。</li></ul><p>信号可以通过 <strong>傅里叶变换（Fourier Transform）</strong> 实现时域与频域之间的转换。</p><h4 id="傅里叶级数展开" tabindex="-1"><a class="header-anchor" href="#傅里叶级数展开"><span>傅里叶级数展开</span></a></h4><figure><img src="'+o+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="傅里叶变换公式" tabindex="-1"><a class="header-anchor" href="#傅里叶变换公式"><span><strong>傅里叶变换公式</strong></span></a></h4><p>连续信号的傅里叶变换定义为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>π</mi><mi>i</mi><mo stretchy="false">(</mo><mi>u</mi><mi>x</mi><mo>+</mo><mi>v</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></msup><mi>d</mi><mi>x</mi><mtext> </mtext><mi>d</mi><mi>y</mi></mrow><annotation encoding="application/x-tex"> F(u, v) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(x, y) e^{-2\\pi i (ux + vy)} dx \\, dy </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3846em;vertical-align:-0.9703em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9703em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9703em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">πi</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">ux</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span></p><p>其中：</p><ul><li>( f(x, y) )：时域/空间域的信号（如图像像素值）。</li><li>( F(u, v) )：频域信号（频率分量）。</li><li>( u, v )：分别表示在 ( x ) 和 ( y ) 方向的频率分量。</li></ul><p>傅里叶逆变换将频域信号转换回空间域：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mi mathvariant="normal">∞</mi></msubsup><mi>F</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>i</mi><mo stretchy="false">(</mo><mi>u</mi><mi>x</mi><mo>+</mo><mi>v</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></msup><mi>d</mi><mi>u</mi><mtext> </mtext><mi>d</mi><mi>v</mi></mrow><annotation encoding="application/x-tex"> f(x, y) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} F(u, v) e^{2\\pi i (ux + vy)} du \\, dv </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3846em;vertical-align:-0.9703em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9703em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4143em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9703em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">πi</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">ux</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span></p><hr><h4 id="离散傅里叶变换-dft" tabindex="-1"><a class="header-anchor" href="#离散傅里叶变换-dft"><span>离散傅里叶变换（DFT）</span></a></h4><p>对于数字图像，其离散傅里叶变换（DFT）公式为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>M</mi><mo>−</mo><mn>1</mn></mrow></munderover><munderover><mo>∑</mo><mrow><mi>y</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>π</mi><mi>i</mi><mrow><mo fence="true">(</mo><mfrac><mrow><mi>u</mi><mi>x</mi></mrow><mi>M</mi></mfrac><mo>+</mo><mfrac><mrow><mi>v</mi><mi>y</mi></mrow><mi>N</mi></mfrac><mo fence="true">)</mo></mrow></mrow></msup></mrow><annotation encoding="application/x-tex"> F(u, v) = \\sum_{x=0}^{M-1} \\sum_{y=0}^{N-1} f(x, y) e^{-2\\pi i \\left( \\frac{ux}{M} + \\frac{vy}{N} \\right)} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2316em;vertical-align:-1.4032em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2671em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4032em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1105em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">πi</span><span class="minner mtight"><span class="mopen sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="mtight">(</span></span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ux</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7699em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.4624em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mclose sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中 ( M ) 和 ( N ) 分别为图像的宽和高。</p><hr><h3 id="_2-高频与低频" tabindex="-1"><a class="header-anchor" href="#_2-高频与低频"><span><strong>2. 高频与低频</strong></span></a></h3><p>在频域中，不同频率对应图像的不同特性：</p><ul><li><strong>低频分量：</strong> 表示变化缓慢的区域，例如大块颜色区域或平滑背景。</li><li><strong>高频分量：</strong> 表示快速变化的区域，例如边缘、细节或噪声。</li></ul><p>通过操控这些分量，可以实现图像处理目标，如模糊、锐化或去噪。</p><hr><h3 id="_3-应用场景" tabindex="-1"><a class="header-anchor" href="#_3-应用场景"><span><strong>3. 应用场景</strong></span></a></h3><h4 id="_1-图像滤波" tabindex="-1"><a class="header-anchor" href="#_1-图像滤波"><span><strong>(1) 图像滤波</strong></span></a></h4><p>滤波是频域分析的核心应用，用于处理图像的特定频率分量：</p><ul><li><strong>低通滤波（Low-pass Filtering）：</strong> 保留低频分量，去除高频分量，适用于模糊和降噪。</li><li><strong>高通滤波（High-pass Filtering）：</strong> 保留高频分量，去除低频分量，适用于边缘检测。</li></ul><p>滤波器在频域中表现为一种掩模，与频谱进行点乘即可完成过滤。</p><hr><h4 id="_2-图像压缩" tabindex="-1"><a class="header-anchor" href="#_2-图像压缩"><span><strong>(2) 图像压缩</strong></span></a></h4><h5 id="jpeg-压缩" tabindex="-1"><a class="header-anchor" href="#jpeg-压缩"><span><strong>JPEG 压缩</strong></span></a></h5><p>JPEG 图像压缩利用 <strong>离散余弦变换（DCT）</strong> 将图像转换到频域中：</p><ol><li>分块处理：将图像划分为 ( 8 \\times 8 ) 的小块。</li><li>DCT 转换：将每个小块转换到频域，公式为：<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mi>C</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mi>C</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><munderover><mo>∑</mo><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><mn>7</mn></munderover><munderover><mo>∑</mo><mrow><mi>y</mi><mo>=</mo><mn>0</mn></mrow><mn>7</mn></munderover><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mi>cos</mi><mo>⁡</mo><mrow><mo fence="true">[</mo><mfrac><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>u</mi><mi>π</mi></mrow><mn>16</mn></mfrac><mo fence="true">]</mo></mrow><mi>cos</mi><mo>⁡</mo><mrow><mo fence="true">[</mo><mfrac><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>v</mi><mi>π</mi></mrow><mn>16</mn></mfrac><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex"> F(u, v) = \\frac{1}{4} C(u)C(v) \\sum_{x=0}^{7} \\sum_{y=0}^{7} f(x, y) \\cos\\left[\\frac{(2x+1)u\\pi}{16}\\right] \\cos\\left[\\frac{(2y+1)v\\pi}{16}\\right] </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.2043em;vertical-align:-1.4032em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2671em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8829em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4032em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">16</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">16</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p></li><li>压缩：去除高频分量（细节与噪声），只保留低频信息。</li><li>量化与编码：将频域系数进一步压缩存储。</li></ol><hr><h4 id="_3-抗混叠与采样" tabindex="-1"><a class="header-anchor" href="#_3-抗混叠与采样"><span><strong>(3) 抗混叠与采样</strong></span></a></h4><h5 id="混叠现象" tabindex="-1"><a class="header-anchor" href="#混叠现象"><span><strong>混叠现象</strong></span></a></h5><p>在图像渲染中，采样频率不足会导致混叠（Aliasing），表现为莫尔条纹或失真。混叠可通过频域分析理解为高频分量的错误映射。</p><h5 id="抗混叠方法" tabindex="-1"><a class="header-anchor" href="#抗混叠方法"><span><strong>抗混叠方法</strong></span></a></h5><ul><li><strong>超采样抗锯齿（SSAA）：</strong> 增加采样点，捕获更多高频信息。</li><li><strong>纹理过滤（Texture Filtering）：</strong> 使用各向异性过滤（Anisotropic Filtering）平滑高频纹理。</li></ul><hr><h4 id="_4-图像恢复与去噪" tabindex="-1"><a class="header-anchor" href="#_4-图像恢复与去噪"><span><strong>(4) 图像恢复与去噪</strong></span></a></h4><p>通过频域方法，可以识别频谱中的噪声分量，并用滤波技术去除它们，从而提升图像质量。</p><hr><h3 id="_4-数学工具" tabindex="-1"><a class="header-anchor" href="#_4-数学工具"><span><strong>4. 数学工具</strong></span></a></h3><p>在计算机图形学中，频域操作依赖高效的数学工具：</p><ul><li><strong>快速傅里叶变换（FFT）：</strong> 用于快速计算离散傅里叶变换，复杂度为 ( O(N \\log N) )。</li><li><strong>卷积定理：</strong><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>↔</mo><mi>F</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>G</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> f(x, y) * g(x, y) \\leftrightarrow F(u, v) \\cdot G(u, v) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↔</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span></p> 卷积操作在频域中转化为简单的乘法，极大提升效率。</li></ul><hr><h3 id="_5-总结" tabindex="-1"><a class="header-anchor" href="#_5-总结"><span><strong>5. 总结</strong></span></a></h3><p>频域是理解和处理图像的重要工具，特别是在图像压缩、滤波、抗混叠等场景中具有不可替代的作用。通过频域分析，可以有效地分离和操控图像的频率分量，从而实现高效的图形处理。如果你有具体的应用问题，欢迎继续深入探讨！</p>',125)]))}const u=a(c,[["render",g],["__file","光栅化.html.vue"]]),v=JSON.parse('{"path":"/posts/%E6%B8%B8%E6%88%8F/games101/%E5%85%89%E6%A0%85%E5%8C%96.html","title":"光栅化","lang":"zh-CN","frontmatter":{"title":"光栅化","date":"2024-11-21T20:41:40.000Z","headerDepth":2,"description":"光栅化 把东西画在频幕上 光栅化（Rasterization）是计算机图形学中将矢量图形（如点、线、三角形等几何图形）转换为光栅图形（即像素网格）的过程。这个过程通常用于实时渲染和显示三维图形到二维屏幕上。以下是光栅化的基本步骤和概念： 顶点处理（Vertex Processing）：首先，图形的顶点数据（如位置、颜色、纹理坐标等）通过顶点着色器进行处...","head":[["meta",{"property":"og:url","content":"https://blog.vipfreevpn.top/posts/%E6%B8%B8%E6%88%8F/games101/%E5%85%89%E6%A0%85%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"博客"}],["meta",{"property":"og:title","content":"光栅化"}],["meta",{"property":"og:description","content":"光栅化 把东西画在频幕上 光栅化（Rasterization）是计算机图形学中将矢量图形（如点、线、三角形等几何图形）转换为光栅图形（即像素网格）的过程。这个过程通常用于实时渲染和显示三维图形到二维屏幕上。以下是光栅化的基本步骤和概念： 顶点处理（Vertex Processing）：首先，图形的顶点数据（如位置、颜色、纹理坐标等）通过顶点着色器进行处..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-24T14:01:41.000Z"}],["meta",{"property":"article:published_time","content":"2024-11-21T20:41:40.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-24T14:01:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"光栅化\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-21T20:41:40.000Z\\",\\"dateModified\\":\\"2024-11-24T14:01:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HideOne\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"光栅化","slug":"光栅化","link":"#光栅化","children":[]},{"level":2,"title":"透视投影","slug":"透视投影","link":"#透视投影","children":[]},{"level":2,"title":"MVP","slug":"mvp","link":"#mvp","children":[]},{"level":2,"title":"三角形","slug":"三角形","link":"#三角形","children":[]},{"level":2,"title":"采样","slug":"采样","link":"#采样","children":[{"level":4,"title":"采样是什么？","slug":"采样是什么","link":"#采样是什么","children":[]}]},{"level":2,"title":"采样伪像（Sampling Artifacts） 反走样","slug":"采样伪像-sampling-artifacts-反走样","link":"#采样伪像-sampling-artifacts-反走样","children":[{"level":3,"title":"锯齿（Aliasing）","slug":"锯齿-aliasing","link":"#锯齿-aliasing","children":[{"level":4,"title":"Aliasing的成因","slug":"aliasing的成因","link":"#aliasing的成因","children":[]},{"level":4,"title":"Aliasing的具体表现","slug":"aliasing的具体表现","link":"#aliasing的具体表现","children":[]},{"level":4,"title":"Aliasing的原因","slug":"aliasing的原因","link":"#aliasing的原因","children":[]}]},{"level":3,"title":"莫尔条纹（Moiré Patterns）","slug":"莫尔条纹-moire-patterns","link":"#莫尔条纹-moire-patterns","children":[{"level":4,"title":"描述","slug":"描述","link":"#描述","children":[]},{"level":4,"title":"成因","slug":"成因","link":"#成因","children":[]},{"level":4,"title":"例子","slug":"例子","link":"#例子","children":[]},{"level":4,"title":"影响","slug":"影响","link":"#影响","children":[]},{"level":4,"title":"反走样解决方法**","slug":"反走样解决方法","link":"#反走样解决方法","children":[{"level":5,"title":"1. 超采样（Supersampling）","slug":"_1-超采样-supersampling","link":"#_1-超采样-supersampling","children":[]},{"level":5,"title":"2. 多重采样抗锯齿（MSAA, Multi-Sample Anti-Aliasing）","slug":"_2-多重采样抗锯齿-msaa-multi-sample-anti-aliasing","link":"#_2-多重采样抗锯齿-msaa-multi-sample-anti-aliasing","children":[]},{"level":5,"title":"3. FXAA (Fast Approximate Anti-Aliasing)","slug":"_3-fxaa-fast-approximate-anti-aliasing","link":"#_3-fxaa-fast-approximate-anti-aliasing","children":[]},{"level":5,"title":"4. Temporal Anti-Aliasing (TAA)","slug":"_4-temporal-anti-aliasing-taa","link":"#_4-temporal-anti-aliasing-taa","children":[]},{"level":5,"title":"5. 采样率调整（Adaptive Sampling）","slug":"_5-采样率调整-adaptive-sampling","link":"#_5-采样率调整-adaptive-sampling","children":[]}]},{"level":4,"title":"总结","slug":"总结","link":"#总结","children":[]}]}]},{"level":2,"title":"频域（Frequency Domain）","slug":"频域-frequency-domain","link":"#频域-frequency-domain","children":[{"level":3,"title":"1. 基本概念","slug":"_1-基本概念","link":"#_1-基本概念","children":[{"level":4,"title":"时域与频域","slug":"时域与频域","link":"#时域与频域","children":[]},{"level":4,"title":"傅里叶级数展开","slug":"傅里叶级数展开","link":"#傅里叶级数展开","children":[]},{"level":4,"title":"傅里叶变换公式","slug":"傅里叶变换公式","link":"#傅里叶变换公式","children":[]},{"level":4,"title":"离散傅里叶变换（DFT）","slug":"离散傅里叶变换-dft","link":"#离散傅里叶变换-dft","children":[]}]},{"level":3,"title":"2. 高频与低频","slug":"_2-高频与低频","link":"#_2-高频与低频","children":[]},{"level":3,"title":"3. 应用场景","slug":"_3-应用场景","link":"#_3-应用场景","children":[{"level":4,"title":"(1) 图像滤波","slug":"_1-图像滤波","link":"#_1-图像滤波","children":[]},{"level":4,"title":"(2) 图像压缩","slug":"_2-图像压缩","link":"#_2-图像压缩","children":[{"level":5,"title":"JPEG 压缩","slug":"jpeg-压缩","link":"#jpeg-压缩","children":[]}]},{"level":4,"title":"(3) 抗混叠与采样","slug":"_3-抗混叠与采样","link":"#_3-抗混叠与采样","children":[{"level":5,"title":"混叠现象","slug":"混叠现象","link":"#混叠现象","children":[]},{"level":5,"title":"抗混叠方法","slug":"抗混叠方法","link":"#抗混叠方法","children":[]}]},{"level":4,"title":"(4) 图像恢复与去噪","slug":"_4-图像恢复与去噪","link":"#_4-图像恢复与去噪","children":[]}]},{"level":3,"title":"4. 数学工具","slug":"_4-数学工具","link":"#_4-数学工具","children":[]},{"level":3,"title":"5. 总结","slug":"_5-总结","link":"#_5-总结","children":[]}]}],"git":{"createdTime":1732202935000,"updatedTime":1732456901000,"contributors":[{"name":"HideOne","email":"844085696@qq.com","commits":2}]},"readingTime":{"minutes":17.45,"words":5236},"filePathRelative":"posts/游戏/games101/光栅化.md","localizedDate":"2024年11月22日","excerpt":"<h2>光栅化</h2>\\n<ul>\\n<li>把东西画在频幕上</li>\\n</ul>\\n<p>光栅化（Rasterization）是计算机图形学中将矢量图形（如点、线、三角形等几何图形）转换为光栅图形（即像素网格）的过程。这个过程通常用于实时渲染和显示三维图形到二维屏幕上。以下是光栅化的基本步骤和概念：</p>\\n<ol>\\n<li>\\n<p><strong>顶点处理（Vertex Processing）</strong>：首先，图形的顶点数据（如位置、颜色、纹理坐标等）通过顶点着色器进行处理，进行变换和投影。</p>\\n</li>\\n<li>\\n<p><strong>裁剪（Clipping）</strong>：将超出视口或视锥体外的部分裁剪掉，只保留需要绘制的部分。</p>\\n</li>\\n<li>\\n<p><strong>三角形设置（Triangle Setup）</strong>：计算三角形的边缘方程，准备进行光栅化。</p>\\n</li>\\n<li>\\n<p><strong>光栅化（Rasterization）</strong>：</p>\\n<ul>\\n<li><strong>采样</strong>：确定哪些像素（或片段）应该被绘制。通常使用边缘方程来判断一个像素是否在三角形内部。</li>\\n<li><strong>插值</strong>：对顶点属性（如颜色、纹理坐标）进行插值，以确定每个像素的最终值。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>片段着色（Fragment Shading）</strong>：每个片段（像素）通过片段着色器进行处理，这里可以进行纹理映射、光照计算等。</p>\\n</li>\\n<li>\\n<p><strong>深度测试（Depth Testing）</strong>：决定哪些片段应该被绘制到屏幕上，通过比较深度缓冲区中的值。</p>\\n</li>\\n<li>\\n<p><strong>混合（Blending）</strong>：如果有透明或半透明的对象，可能需要进行混合操作来正确渲染透明度。</p>\\n</li>\\n</ol>","autoDesc":true}');export{u as comp,v as data};
