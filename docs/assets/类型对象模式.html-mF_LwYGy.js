const e=JSON.parse('{"key":"v-7b44c762","path":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F.html","title":"类型对象模式","lang":"zh-CN","frontmatter":{"title":"类型对象模式","category":["游戏"],"date":"2023-12-26T16:00:00.000Z","headerDepth":2,"description":"是什么 通过创建一个类来支持新类型的灵活创建，其每个实例都代表一个不同的对象类型 为什么使用 当我们有一个需求比如 要创建一大堆不同种类怪物他们都有自己的攻击力 生命值...时 首先想到是的定义怪物基类 其余种类怪物继承至它 这样会导致类随怪物数量增加而增加 怎么用 让两个类的引用组合实现无数种怪物的需求 // 每个怪物的属性值 class Breed { public: Breed(int health, const char* attack) : health_(health), attack_(attack) {} int getHealth() { return health_; } const char* getAttack() { return attack_; } private: int health_; // Starting health. const char* attack_; }; class Monster { public: Monster(Breed&amp; breed) : health_(breed.getHealth()), breed_(breed) {} const char* getAttack() { return breed_.getAttack(); } private: // Current health. int health_; // 不同种类怪物 拥有不同属性 Breed&amp; breed_; };","head":[["meta",{"property":"og:url","content":"https://blog.vipfreevpn.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"博客"}],["meta",{"property":"og:title","content":"类型对象模式"}],["meta",{"property":"og:description","content":"是什么 通过创建一个类来支持新类型的灵活创建，其每个实例都代表一个不同的对象类型 为什么使用 当我们有一个需求比如 要创建一大堆不同种类怪物他们都有自己的攻击力 生命值...时 首先想到是的定义怪物基类 其余种类怪物继承至它 这样会导致类随怪物数量增加而增加 怎么用 让两个类的引用组合实现无数种怪物的需求 // 每个怪物的属性值 class Breed { public: Breed(int health, const char* attack) : health_(health), attack_(attack) {} int getHealth() { return health_; } const char* getAttack() { return attack_; } private: int health_; // Starting health. const char* attack_; }; class Monster { public: Monster(Breed&amp; breed) : health_(breed.getHealth()), breed_(breed) {} const char* getAttack() { return breed_.getAttack(); } private: // Current health. int health_; // 不同种类怪物 拥有不同属性 Breed&amp; breed_; };"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"HideOne"}],["meta",{"property":"article:published_time","content":"2023-12-26T16:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类型对象模式\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-12-26T16:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HideOne\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"是什么","slug":"是什么","link":"#是什么","children":[]},{"level":2,"title":"为什么使用","slug":"为什么使用","link":"#为什么使用","children":[]},{"level":2,"title":"怎么用","slug":"怎么用","link":"#怎么用","children":[]},{"level":2,"title":"问题","slug":"问题","link":"#问题","children":[]},{"level":2,"title":"解决","slug":"解决","link":"#解决","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.06,"words":319},"filePathRelative":"posts/设计模式/类型对象模式.md","localizedDate":"2023年12月27日","excerpt":"<h2> 是什么</h2>\\n<p>通过创建一个类来支持新类型的灵活创建，其每个实例都代表一个不同的对象类型</p>\\n<h2> 为什么使用</h2>\\n<p>当我们有一个需求比如 要创建一大堆不同种类怪物他们都有自己的攻击力 生命值...时 首先想到是的定义怪物基类 其余种类怪物继承至它  这样会导致类随怪物数量增加而增加</p>\\n<h2> 怎么用</h2>\\n<p>让两个类的引用组合实现无数种怪物的需求</p>\\n<div class=\\"language-C++ line-numbers-mode\\" data-ext=\\"C++\\"><pre class=\\"language-C++\\"><code>    // 每个怪物的属性值\\n    class Breed\\n    {\\n    public:\\n      Breed(int health, const char* attack)\\n      : health_(health),\\n        attack_(attack)\\n      {}\\n\\n      int getHealth() { return health_; }\\n      const char* getAttack() { return attack_; }\\n\\n    private:\\n      int health_; // Starting health.\\n      const char* attack_;\\n    };\\n\\n        class Monster\\n    {\\n    public:\\n      Monster(Breed&amp; breed)\\n      : health_(breed.getHealth()),\\n        breed_(breed)\\n      {}\\n\\n      const char* getAttack()\\n      {\\n        return breed_.getAttack();\\n      }\\n    private:\\n      // Current health.\\n      int health_;\\n      // 不同种类怪物 拥有不同属性\\n      Breed&amp; breed_;\\n    };\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{e as data};
